#include <reg52.h>
#include <intrins.h>
#include "temp.h"
/*******************************************************************************
* 函 数 名         : DelayX10us(u8 t)										   *
* 函数功能		   : 延时				  					   	   	   		   *
* 输    入         : t（延时时间）										       *
* 输    出         : 无														   *
*******************************************************************************/
void DelayX10us(u8 t)
{
	 do {
	 _nop_();
	 _nop_();
	 _nop_();
	 _nop_();
	 _nop_();
	 _nop_();
	 _nop_();
	 _nop_();
	 } while (--t);
}
/*******************************************************************************
* 函 数 名         :Get18B20Ack()										   	   *
* 函数功能		   :检测18b20是否响应				  					   	   *
* 输    入         : 无										      			   *
* 输    出         : 无														   *
*******************************************************************************/
bit Get18B20Ack()
{
 	 bit ack; 
	 EA = 0; //禁止总中断
	 IO_18B20 = 0; //产生 500us 复位脉冲
	 DelayX10us(50);
	 IO_18B20 = 1;
	 DelayX10us(6); //延时 60us
	 ack = IO_18B20; //读取存在脉冲
	 while(!IO_18B20); //等待存在脉冲结束
	 EA = 1; //重新使能总中断
	 
	 return ack;
}
/*******************************************************************************
* 函 数 名         :Write18B20(u8 dat)										   *
* 函数功能		   :向18b20写入字节				  					   	  	   *
* 输    入         : dat（写入的数据）										   *
* 输    出         : 无														   *
*******************************************************************************/
void Write18B20(u8 dat)
{
	 u8 mask;	 
	 EA = 0; //禁止总中断
	 for (mask=0x01; mask!=0; mask<<=1) //低位在先，依次移出 8 个 bit
	 {
		 IO_18B20 = 0; //产生 2us 低电平脉冲
		 _nop_();
		 _nop_();
		 if ((mask&dat) == 0) //输出该 bit 值
		 IO_18B20 = 0;
		 else
		 IO_18B20 = 1;
		 DelayX10us(6); //延时 60us
		 IO_18B20 = 1; //拉高通信引脚
	 }
	 EA = 1; //重新使能总中断
}
/*******************************************************************************
* 函 数 名         :Read18B20()										   		   *
* 函数功能		   :向18b20读取字节				  					   	  	   *
* 输    入         :无										   				   *
* 输    出         : 读取的字节												   *
*******************************************************************************/
u8 Read18B20()
{
	 u8 dat;
	 u8 mask;	 
	 EA = 0; //禁止总中断
	 for (mask=0x01; mask!=0; mask<<=1) //低位在先，依次采集 8 个 bit
	 {
		 IO_18B20 = 0; //产生 2us 低电平脉冲
		 _nop_();
		 _nop_();
		 IO_18B20 = 1; //结束低电平脉冲，等待 18B20 输出数据
		 _nop_(); //延时 2us
		 _nop_();
		 if (!IO_18B20) //读取通信引脚上的值
		 dat &= ~mask;
		 else
		 dat |= mask;
		 DelayX10us(6); //再延时 60us
	 }
	 EA = 1; //重新使能总中断
	 return dat;
}
/*******************************************************************************
* 函 数 名         :Start18B20()									   		   *
* 函数功能		   :启动一次18b20温度转换				  					   *
* 输    入         :无										   				   *
* 输    出         :是否成功											       *
*******************************************************************************/
bit Start18B20()
{
	 bit ack;	 
	 ack = Get18B20Ack(); //执行总线复位，并获取 18B20 应答
	 if (ack == 0) //如 18B20 正确应答，则启动一次转换
	 {
		 Write18B20(0xCC); //跳过 ROM 操作
		 Write18B20(0x44); //启动一次温度转换
	 }
	 return ~ack; //ack==0 表示操作成功，所以返回值对其取反
}
/* 读取 DS18B20 转换的温度值，返回值-表示是否读取成功 */
/*******************************************************************************
* 函 数 名         :Get18B20Temp(int *temp)									   *
* 函数功能		   :读取18b20温度数据				  					   	   *
* 输    入         :temp(存取温度)										   	   *
* 输    出         :是否成功											       *
*******************************************************************************/
bit Get18B20Temp(int *temp)
{
	 bit ack;
	 u8 LSB, MSB; //16bit 温度值的低字节和高字节	 
	 ack = Get18B20Ack(); //执行总线复位，并获取 18B20 应答
	 if (ack == 0) //如 18B20 正确应答，则读取温度值
	 {
		 Write18B20(0xCC); //跳过 ROM 操作
		 Write18B20(0xBE); //发送读命令
		 LSB = Read18B20(); //读温度值的低字节
		 MSB = Read18B20(); //读温度值的高字节
		 *temp = ((int)MSB << 8) + LSB; //合成为 16bit 整型数
	 }
	 return ~ack; //ack==0 表示操作应答，所以返回值为其取反值
}
